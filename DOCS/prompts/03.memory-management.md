**Role:** Act as a Senior Python Systems Engineer and Performance Architect.

**Objective:** Create a technical demonstration of Python Memory Management, specifically comparing standard object overhead versus `__slots__` optimization.

**Path & Structure:**

- **Folder:** `03.Memory-Management-Slots/` (Corrected from your draft to keep topics separated).
- **Primary File:** `memory_optimization_demo.py`
- **Goal:** Compare the memory footprint of 1 million instances of a class with and without `__slots__`.

**Task Requirements:**

1. **The Memory Benchmark:**

   - Create two classes: `StandardCoordinate` (normal) and `OptimizedCoordinate` (using `__slots__`).
   - Use the `sys.getsizeof` or the `pympler` library (if available, otherwise use a manual memory delta calculation) to show the total memory consumed by a list of 1,000,000 objects of each type.

2. **The "Killer" Interview Context:**

   - Implement a small section in the code that intentionally creates a **Circular Reference** (e.g., `self.friend = friend`) and explain in comments why Reference Counting fails here and how the Generational Garbage Collector (`gc` module) is forced to step in.

3. **Technical Annotations:**

   - Add comments explaining how `__slots__` prevents the creation of the `__dict__` and `__weakref__` attributes, which is where the memory saving actually comes from.
   - Explain the **Trade-off**: Why using `__slots__` makes the class "static" (you cannot add new attributes at runtime).

4. **Comparison Context:**
   - Include a blockquote comparing Pythonâ€™s "Immediate Cleanup" (Ref Counting) vs. Node.js V8 "Mark-and-Sweep". Explain how `__slots__` is closer to how a C struct or a TypeScript Interface (with a hidden class in V8) would behave in memory.

**Output Format:**

- **File Tree:** Visual layout of the created directory.
- **Code:** Highly optimized, PEP-8 compliant code that produces a clear memory report in the console.
